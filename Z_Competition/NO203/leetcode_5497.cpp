//          5497. 查找大小为 M 的最新分组
//
// 给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。
// 在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。
// 给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。
// 返回存在长度 恰好 为 m 的 一组 1  的最后步骤。如果不存在这样的步骤，请返回 -1 。
//
// 示例 1：
// 输入：arr = [3,5,1,2,4], m = 1
// 输出：4
// 解释：
// 步骤 1："00100"，由 1 构成的组：["1"]
// 步骤 2："00101"，由 1 构成的组：["1", "1"]
// 步骤 3："10101"，由 1 构成的组：["1", "1", "1"]
// 步骤 4："11101"，由 1 构成的组：["111", "1"]
// 步骤 5："11111"，由 1 构成的组：["11111"]
// 存在长度为 1 的一组 1 的最后步骤是步骤 4 。
//
//
// 示例 2：
// 输入：arr = [3,1,5,4,2], m = 2
// 输出：-1
// 解释：
// 步骤 1："00100"，由 1 构成的组：["1"]
// 步骤 2："10100"，由 1 构成的组：["1", "1"]
// 步骤 3："10101"，由 1 构成的组：["1", "1", "1"]
// 步骤 4："10111"，由 1 构成的组：["1", "111"]
// 步骤 5："11111"，由 1 构成的组：["11111"]
// 不管是哪一步骤都无法形成长度为 2 的一组 1 。
//
//
// 示例 3：
// 输入：arr = [1], m = 1
// 输出：1
//
//
// 示例 4：
// 输入：arr = [2,1], m = 2
// 输出：2
//  
//
// 提示：
// n == arr.length
// 1 <= n <= 10^5
// 1 <= arr[i] <= n
// arr 中的所有整数 互不相同
// 1 <= m <= arr.length


#include<bits/stdc++.h>
using namespace std;

// Medium

class Solution {
public:
    int findLatestStep(vector<int>& arr, int m) {
        int n = arr.size(); 
        vector<int> left(n+2,0);		 // 左指针
        vector<int> right(n+2,0);		 // 右指针
   
        int cnt = 0;					 // 计数器
        int ans = -1;                    // 返回答案

        // 判断此时线段的长度
        function<int(int)> get = [&](int t){
            return right[t]-t+1;
        };

        for(int i = 0; i < n; ++i)
        {
            int x = arr[i];
            if(left[x-1] && right[x+1])
            {
                // 左边和右边都判断是否满足关系，满足则合并时cnt--;
                if(get(left[x-1]) == m)     cnt--;
                if(get(left[right[x+1]]) == m)    cnt--;
                
                // 左端点的右指向右端点，右端点的左指向左端点
                right[left[x-1]] = right[x+1];
                left[right[x+1]] = left[x-1];   

                // 最后合并后也要判断一下是否满足 m 满足就 cnt++;
                if(get(left[right[x+1]]) == m)      cnt++; 
            }
            else if(left[x-1])
            {
                if(get(left[x-1]) == m)     cnt--;

                right[left[x-1]] = x;
                left[x] = left[x-1];

                if(get(left[x]) == m)       cnt++;
            }
            else if(right[x+1])
            {
                if(get(x+1) == m)           cnt--;

                right[x] = right[x+1];
                left[right[x+1]] = x;

                if(get(x) == m)     cnt++;
            }
            else
            {
                left[x] = x;
                right[x] = x;
                
                // 左右区间的指针都为空的时候就判断 m 是否为1
                if(m == 1)
                { 
                    cnt++;
                }
            }
		
            // 只要 cnt 存在说明此步骤有效将返回值置于此步骤
            if(cnt)
            {
                ans = i+1;
            }
        }

        return ans;
    }
};