//                   5492. 分割字符串的方案数
//
// 给你一个二进制串 s  （一个只包含 0 和 1 的字符串），我们可以将 s 分割成 3 个 非空 字符串 s1, s2, s3 （s1 + s2 + s3 = s）。
// 请你返回分割 s 的方案数，满足 s1，s2 和 s3 中字符 '1' 的数目相同。
// 由于答案可能很大，请将它对 10^9 + 7 取余后返回。
//
//
// 示例 1：
// 输入：s = "10101"
// 输出：4
// 解释：总共有 4 种方法将 s 分割成含有 '1' 数目相同的三个子字符串。
// "1|010|1"
// "1|01|01"
// "10|10|1"
// "10|1|01"
//
// 示例 2：
// 输入：s = "1001"
// 输出：0
//
// 示例 3：
// 输入：s = "0000"
// 输出：3
// 解释：总共有 3 种分割 s 的方法。
// "0|0|00"
// "0|00|0"
// "00|0|0"
//
// 示例 4：
// 输入：s = "100100010100110"
// 输出：12
//
//
// 提示：
// s[i] == '0' 或者 s[i] == '1'
// 3 <= s.length <= 10^5



#include<bits/stdc++.h>
using namespace std;

// Medium

class Solution {
public:
    int MOD = 1e9 + 7;
    
    int numWays(string s) {
        int n = s.size();
        int sum = 0;

        // 先统计 1 的个数，判断是否能被 3 整除
        for (int i = 0; i < n; i++) 
        {
            sum += (s[i] == '1');
        }

        int c1 = 0, c2 = 0;
        
        // 不能被 3 整除的就直接返回 0
        if (sum % 3 != 0) 
        {
            return 0;
        }
        
        // 如果全部为 0 就直接用高斯定律求和
        if (sum == 0) 
        {
            if (n < 3) 
            {
                return 0;
            }
            int s1 = n - 1;
            return (long long)s1 * (s1 - 1) / 2 % MOD;
        }

        // need 为每一组需要 1 的个数
        int need = sum / 3, now = 0, s1 = 0, s2 = 0;
        
        // 找到第一组和第二组直接的 0 的个数 和 第二组和第三组之间 0 的个数 然后相乘就可以
        for (int i = 0; i < n; i++) 
        {
            now += (s[i] == '1');
            if (now == need) 
            {
                s1++;
            }
            if (now == need * 2) 
            {
                s2++;
            }
        }
        
        return (long long)s1 * s2 % MOD;
    }
};